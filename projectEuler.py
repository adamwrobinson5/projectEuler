# #Project Euler

import math
import sys
import time

# # ***** PROBLEM 1 *****
# # If we list all the natural numbers below 10 that are multiples 
# # of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# # Find the sum of all the multiples of 3 or 5 below 1000.

# print ''
# print '*** PROBLEM 1 ***'
# print ''
# sum = 0
# for x in range(1,1000):
#     if (x % 3 == 0 or x % 5 == 0):
#         sum += x
# print 'ANSWER: ' + str(sum)




# # ***** PROBLEM 2 *****
# # Each new term in the Fibonacci sequence is generated by adding the
# # previous two terms. By starting with 1 and 2, the first 10 terms 
# # will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# # By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

# print ''
# print '*** PROBLEM 2 ***'
# print ''
# fibArr = [1,2]
# evenArr = [2]
# sumEven = 2
# add = 0
# x = 2
# while add < 4000000:
#     add = fibArr[x-1] + fibArr[(x-2)]
#     if add % 2 == 0:
#         evenArr.append(add)
#         sumEven += add
#     fibArr.append(add)
#     x += 1
# fibArr.remove(add)
# print 'ANSWER: ' + str(sumEven)




# # ***** PROBLEM 3 *****
# # The prime factors of 13195 are 5, 7, 13 and 29.
# # What is the largest prime factor of the number 600851475143?

# print ''
# print '*** PROBLEM 3 ***'
# print ''
# primeArray = []
# x = 600851475143
# for i in range(3,int(math.sqrt(x))):
#     while x % i == 0:
#         primeArray.append(i)
#         x = x/i
# print 'ANSWER: ' + str(primeArray[-1])




# # ***** PROBLEM 4 *****
# # A palindromic number reads the same both ways. The largest
# # palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
# # Find the largest palindrome made from the product of two 3-digit numbers.

# print ''
# print '*** PROBLEM 4 ***'
# print ''
# a = 999
# b = 999
# palArray = []
# while b >= 100:
#     a = 999
#     while a >= 100:
#         front = []
#         back = []
#         revBack = []
#         mult = a * b
#         num = str(mult)
#         if len(num) == 6:
#             for i in range(0, 3):
#                 front.append(int(num[i]))
#             for j in range(3, 6):
#                 back.append(int(num[j]))
#             revBack.append(back[2])
#             revBack.append(back[1])
#             revBack.append(back[0])
#             if cmp(front, revBack) == 0:
#                 palArray.append(mult)
#         a -= 1
#     b -= 1
# sort = sorted(palArray)
# largestPalindrome = sort[-1]
# print 'ANSWER: ' + str(largestPalindrome)




# # ***** PROBLEM 5 *****
# # 2520 is the smallest number that can be divided by each of the numbers 
# # from 1 to 10 without any remainder. What is the smallest positive number 
# # that is evenly divisible by all of the numbers from 1 to 20?

# print ''
# print '*** PROBLEM 5 ***'
# print ''
# num = 1
# primeArray = []
# for x in range(2,21):
#     primeCheck = 0
#     for y in range(2, x+1):
#         if x % y != 0:
#             primeCheck += 1
#         elif x != 2:
#             break
#         if primeCheck == x-2 or x == 2:
#             pwr = 1
#             exp = 0
#             while exp < 20:
#                 exp = x**pwr
#                 primeArray.append(x)
#                 pwr += 1
#             primeArray.remove(x)
#             break
# for i in range(0, len(primeArray)):
#     num *= primeArray[i]
# print 'ANSWER: ' + str(num)




# # ***** PROBLEM 6 *****
# # The sum of the squares of the first ten natural numbers is,
# # 1**2 + 2**2 + ... + 10**2 = 385
# # The square of the sum of the first ten natural numbers is,
# # (1 + 2 + ... + 10)**2 = 552 = 3025
# # Hence the difference between the sum of the squares of the 
# # first ten natural numbers and the square of the sum is 
# # 3025 - 385 = 2640
# # Find the difference between the sum of the squares of the 
# # first one hundred natural numbers and the square of the sum.

# print ''
# print '*** PROBLEM 6 ***'
# print ''
# natSum = 0
# natSqr = 0
# for x in range(1,101):
#     natSum += x**2
# for x in range(1,101):
#     natSqr += x
# natSqr **= 2
# diff = natSqr - natSum
# print 'ANSWER: ' + str(diff)




# # ***** PROBLEM 7 *****
# # By listing the first six prime numbers: 
# # 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
# # What is the 10001st prime number?

# print ''
# print '*** PROBLEM 7 ***'
# print ''
# primeArray = []
# done = False
# def prime(x):
#     for j in range(2, int(math.floor(math.sqrt(x)+1))):
#         if x % j == 0:
#             return 0
#     return 1
# for i in range(2, 110000):
#     if prime(i) == 1:
#         primeArray.append(i)
#     if len(primeArray) == 10001:
#         done = True
#     if done == True:
#         break
# print primeArray[-1]




# # ***** PROBLEM 8 *****
# # The four adjacent digits in the 1000-digit number that 
# # have the greatest product are 9 * 9 * 8 * 9 = 5832
# # Find the thirteen adjacent digits in the 1000-digit number 
# # that have the greatest product. What is the value of this product?

# print ''
# print '*** PROBLEM 8 ***'
# print ''
# product = 0
# greatestProduct = 0
# number = str(7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)
# for x in range(0,988):
#     product = int(number[x]) * int((number[x+1])) * int((number[x+2])) * int((number[x+3])) * int((number[x+4])) * int((number[x+5])) * int((number[x+6])) * int((number[x+7])) * int((number[x+8])) * int((number[x+9])) * int((number[x+10])) * int((number[x+11])) * int((number[x+12]))
#     if product > greatestProduct:
#         zero = number[x]
#         one = number[x + 1]
#         two = number[x + 2]
#         three = number[x + 3]
#         four = number[x + 4]
#         five = number[x + 5]
#         six = number[x + 6]
#         seven = number[x + 7]
#         eight = number[x + 8]
#         nine = number[x + 9]
#         ten = number[x + 10]
#         eleven = number[x + 11]
#         twelve = number[x + 12]
#         greatestProduct = product
# print 'zero: ' + str(zero)
# print 'one: ' + str(one)
# print 'two: ' + str(two)
# print 'three: ' + str(three)
# print 'four: ' + str(four)
# print 'five: ' + str(five)
# print 'six: ' + str(six)
# print 'seven: ' + str(seven)
# print 'eight: ' + str(eight)
# print 'nine: ' + str(nine)
# print 'ten: ' + str(ten)
# print 'eleven: ' + str(eleven)
# print 'twelve: ' + str(twelve)
# print greatestProduct




# # ***** PROBLEM 9 *****
# # A Pythagorean triplet is a set of three natural numbers, a < b < c, 
# # for which, a**2 + b**2 = c**2
# # For example, 3**2 + 4**2 = 9 + 16 = 25 = 5**2.
# # There exists exactly one Pythagorean triplet for which a + b + c = 1000.
# # Find the product a * b * c.

# print ''
# print '*** PROBLEM 9 ***'
# print ''
# def triplet():
#     done = False
#     for c in range(3,1000):
#         for b in range(2, c):
#             for a in range(1, b):
#                 sum = a + b + c
#                 if sum > 1000:
#                     break
#                 if sum == 1000:
#                     if a**2 + b**2 == c**2:
#                         triplet = a * b * c
#                         done = True
#                     if done == True:
#                         print 'end a: ' + str(a)
#                         print 'end b: ' + str(b)
#                         print 'end c: ' + str(c)
#                         print 'triplet: ' + str(triplet)
#                         return
# triplet()




# # ***** PROBLEM 10 *****
# # The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
# # Find the sum of all the primes below two million.

# print ''
# print '*** PROBLEM 10 ***'
# print ''
# sum = 0
# primeArray = []
# def prime(x):
#     if x % 1000 == 0:
#     for j in range(2, int(math.floor(math.sqrt(x)+1))):
#         if x % j == 0:
#             return 0
#     return 1
# for i in range(2, 2000000):
#     if prime(i) == 1:
#         sum += i
# print sum




# # ***** PROBLEM 11 *****
# # In the 20*20 grid below, four numbers along a diagonal line have been marked in brackets.

# # 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
# # 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
# # 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
# # 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
# # 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
# # 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
# # 32 98 81 28 64 23 67 10 {26} 38 40 67 59 54 70 66 18 38 64 70
# # 67 26 20 68 02 62 12 20 95 {63} 94 39 63 08 40 91 66 49 94 21
# # 24 55 58 05 66 73 99 26 97 17 {78} 78 96 83 14 88 34 89 63 72
# # 21 36 23 09 75 00 76 44 20 45 35 {14} 00 61 33 97 34 31 33 95
# # 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
# # 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
# # 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
# # 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
# # 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
# # 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
# # 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
# # 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
# # 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
# # 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
# # The product of these numbers is 26 * 63 * 78 * 14 = 1788696.

# # What is the greatest product of four adjacent numbers in the same direction 
# # (up, down, left, right, or diagonally) in the 20*20 grid?

# print ''
# print '*** PROBLEM 11 ***'
# print ''
# grid = '\
# 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n\
# 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n\
# 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n\
# 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n\
# 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n\
# 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n\
# 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n\
# 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n\
# 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n\
# 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n\
# 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n\
# 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n\
# 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n\
# 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n\
# 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n\
# 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n\
# 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n\
# 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n\
# 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n\
# 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48'
# gridArray = []
# for line in grid.split('\n'):
#     gridArray.append(map(int, line.split(' ')))
# greatestProduct = 0
# def diagonalRight():
#     diagonalRightProduct = 0
#     for x in range(0, 17):
#         for y in range(0, 17):
#             a = gridArray[x][y]
#             b = gridArray[x+1][y+1]
#             c = gridArray[x+2][y+2]
#             d = gridArray[x+3][y+3]
#             if a * b * c * d > diagonalRightProduct:
#                 diagonalRightProduct = a * b * c * d  
#     return diagonalRightProduct    
# def diagonalLeft():
#     diagonalLeftProduct = 0
#     for x in range(0, 17):
#         for y in range(0, 17):
#             d = gridArray[x][y+3]
#             c = gridArray[x+1][y+2]
#             b = gridArray[x+2][y+1]
#             a = gridArray[x+3][y]
#             if a * b * c * d > diagonalLeftProduct:
#                 diagonalLeftProduct = a * b * c * d  
#     return diagonalLeftProduct              
# def vertical():
#     verticalProduct = 0
#     for x in range(0, 17):
#         for y in range(0, 17):
#             a = gridArray[x][y]
#             b = gridArray[x+1][y]
#             c = gridArray[x+2][y]
#             d = gridArray[x+3][y]
#             if a * b * c * d > verticalProduct:
#                 verticalProduct = a * b * c * d 
#     return verticalProduct
# def horizontal():
#     horizontalProduct = 0
#     for x in range(0, 17):
#         for y in range(0, 17):
#             a = gridArray[x][y]
#             b = gridArray[x][y+1]
#             c = gridArray[x][y+2]
#             d = gridArray[x][y+3]
#             if a * b * c * d > horizontalProduct:
#                 horizontalProduct = a * b * c * d 
#     return horizontalProduct
# diagonalRight = diagonalRight()
# diagonalLeft = diagonalLeft()
# vertical = vertical()
# horizontal = horizontal()
# greatestProduct = [diagonalLeft, diagonalRight, vertical, horizontal]
# greatestProduct = sorted(greatestProduct)
# print 'Greatest Product: ' + str(greatestProduct[3])




# # ***** PROBLEM 12 *****
# # The sequence of triangle numbers is generated by adding the natural 
# # numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
# # The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# # Let us list the factors of the first seven triangle numbers:
# #  1: 1
# #  3: 1,3
# #  6: 1,2,3,6
# # 10: 1,2,5,10
# # 15: 1,3,5,15
# # 21: 1,3,7,21
# # 28: 1,2,4,7,14,28
# # We can see that 28 is the first triangle number to have over five divisors.
# # What is the value of the first triangle number to have over five hundred divisors?

# print ''
# print '*** PROBLEM 12 ***'
# print ''
# done = False
# def divisor(i):
#     count = 1
#     for j in range(1, int((math.ceil(math.sqrt(i))))):
#         if i % j == 0:
#             count += 2
#     return count
# x = 1
# k = 2
# while done == False:
#     x = x + k
#     if divisor(x) > 500:
#         print 'Triangle Number: ' + str(x)
#         done = True
#     k += 1




# # ***** PROBLEM 13 *****
# # Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
# # 37107287533902102798797998220837590246510135740250
# # 46376937677490009712648124896970078050417018260538
# # 74324986199524741059474233309513058123726617309629
# # 91942213363574161572522430563301811072406154908250
# # 23067588207539346171171980310421047513778063246676
# # 89261670696623633820136378418383684178734361726757
# # 28112879812849979408065481931592621691275889832738
# # 44274228917432520321923589422876796487670272189318
# # 47451445736001306439091167216856844588711603153276
# # 70386486105843025439939619828917593665686757934951
# # 62176457141856560629502157223196586755079324193331
# # 64906352462741904929101432445813822663347944758178
# # 92575867718337217661963751590579239728245598838407
# # 58203565325359399008402633568948830189458628227828
# # 80181199384826282014278194139940567587151170094390
# # 35398664372827112653829987240784473053190104293586
# # 86515506006295864861532075273371959191420517255829
# # 71693888707715466499115593487603532921714970056938
# # 54370070576826684624621495650076471787294438377604
# # 53282654108756828443191190634694037855217779295145
# # 36123272525000296071075082563815656710885258350721
# # 45876576172410976447339110607218265236877223636045
# # 17423706905851860660448207621209813287860733969412
# # 81142660418086830619328460811191061556940512689692
# # 51934325451728388641918047049293215058642563049483
# # 62467221648435076201727918039944693004732956340691
# # 15732444386908125794514089057706229429197107928209
# # 55037687525678773091862540744969844508330393682126
# # 18336384825330154686196124348767681297534375946515
# # 80386287592878490201521685554828717201219257766954
# # 78182833757993103614740356856449095527097864797581
# # 16726320100436897842553539920931837441497806860984
# # 48403098129077791799088218795327364475675590848030
# # 87086987551392711854517078544161852424320693150332
# # 59959406895756536782107074926966537676326235447210
# # 69793950679652694742597709739166693763042633987085
# # 41052684708299085211399427365734116182760315001271
# # 65378607361501080857009149939512557028198746004375
# # 35829035317434717326932123578154982629742552737307
# # 94953759765105305946966067683156574377167401875275
# # 88902802571733229619176668713819931811048770190271
# # 25267680276078003013678680992525463401061632866526
# # 36270218540497705585629946580636237993140746255962
# # 24074486908231174977792365466257246923322810917141
# # 91430288197103288597806669760892938638285025333403
# # 34413065578016127815921815005561868836468420090470
# # 23053081172816430487623791969842487255036638784583
# # 11487696932154902810424020138335124462181441773470
# # 63783299490636259666498587618221225225512486764533
# # 67720186971698544312419572409913959008952310058822
# # 95548255300263520781532296796249481641953868218774
# # 76085327132285723110424803456124867697064507995236
# # 37774242535411291684276865538926205024910326572967
# # 23701913275725675285653248258265463092207058596522
# # 29798860272258331913126375147341994889534765745501
# # 18495701454879288984856827726077713721403798879715
# # 38298203783031473527721580348144513491373226651381
# # 34829543829199918180278916522431027392251122869539
# # 40957953066405232632538044100059654939159879593635
# # 29746152185502371307642255121183693803580388584903
# # 41698116222072977186158236678424689157993532961922
# # 62467957194401269043877107275048102390895523597457
# # 23189706772547915061505504953922979530901129967519
# # 86188088225875314529584099251203829009407770775672
# # 11306739708304724483816533873502340845647058077308
# # 82959174767140363198008187129011875491310547126581
# # 97623331044818386269515456334926366572897563400500
# # 42846280183517070527831839425882145521227251250327
# # 55121603546981200581762165212827652751691296897789
# # 32238195734329339946437501907836945765883352399886
# # 75506164965184775180738168837861091527357929701337
# # 62177842752192623401942399639168044983993173312731
# # 32924185707147349566916674687634660915035914677504
# # 99518671430235219628894890102423325116913619626622
# # 73267460800591547471830798392868535206946944540724
# # 76841822524674417161514036427982273348055556214818
# # 97142617910342598647204516893989422179826088076852
# # 87783646182799346313767754307809363333018982642090
# # 10848802521674670883215120185883543223812876952786
# # 71329612474782464538636993009049310363619763878039
# # 62184073572399794223406235393808339651327408011116
# # 66627891981488087797941876876144230030984490851411
# # 60661826293682836764744779239180335110989069790714
# # 85786944089552990653640447425576083659976645795096
# # 66024396409905389607120198219976047599490197230297
# # 64913982680032973156037120041377903785566085089252
# # 16730939319872750275468906903707539413042652315011
# # 94809377245048795150954100921645863754710598436791
# # 78639167021187492431995700641917969777599028300699
# # 15368713711936614952811305876380278410754449733078
# # 40789923115535562561142322423255033685442488917353
# # 44889911501440648020369068063960672322193204149535
# # 41503128880339536053299340368006977710650566631954
# # 81234880673210146739058568557934581403627822703280
# # 82616570773948327592232845941706525094512325230608
# # 22918802058777319719839450180888072429661980811197
# # 77158542502016545090413245809786882778948721859617
# # 72107838435069186155435662884062257473692284509516
# # 20849603980134001723930671666823555245252804609722
# # 53503534226472524250874054075591789781264330331690

# print ''
# print '*** PROBLEM 13 ***'
# print ''
# array = [
# 37107287533902102798797998220837590246510135740250,
# 46376937677490009712648124896970078050417018260538,
# 74324986199524741059474233309513058123726617309629,
# 91942213363574161572522430563301811072406154908250,
# 23067588207539346171171980310421047513778063246676,
# 89261670696623633820136378418383684178734361726757,
# 28112879812849979408065481931592621691275889832738,
# 44274228917432520321923589422876796487670272189318,
# 47451445736001306439091167216856844588711603153276,
# 70386486105843025439939619828917593665686757934951,
# 62176457141856560629502157223196586755079324193331,
# 64906352462741904929101432445813822663347944758178,
# 92575867718337217661963751590579239728245598838407,
# 58203565325359399008402633568948830189458628227828,
# 80181199384826282014278194139940567587151170094390,
# 35398664372827112653829987240784473053190104293586,
# 86515506006295864861532075273371959191420517255829,
# 71693888707715466499115593487603532921714970056938,
# 54370070576826684624621495650076471787294438377604,
# 53282654108756828443191190634694037855217779295145,
# 36123272525000296071075082563815656710885258350721,
# 45876576172410976447339110607218265236877223636045,
# 17423706905851860660448207621209813287860733969412,
# 81142660418086830619328460811191061556940512689692,
# 51934325451728388641918047049293215058642563049483,
# 62467221648435076201727918039944693004732956340691,
# 15732444386908125794514089057706229429197107928209,
# 55037687525678773091862540744969844508330393682126,
# 18336384825330154686196124348767681297534375946515,
# 80386287592878490201521685554828717201219257766954,
# 78182833757993103614740356856449095527097864797581,
# 16726320100436897842553539920931837441497806860984,
# 48403098129077791799088218795327364475675590848030,
# 87086987551392711854517078544161852424320693150332,
# 59959406895756536782107074926966537676326235447210,
# 69793950679652694742597709739166693763042633987085,
# 41052684708299085211399427365734116182760315001271,
# 65378607361501080857009149939512557028198746004375,
# 35829035317434717326932123578154982629742552737307,
# 94953759765105305946966067683156574377167401875275,
# 88902802571733229619176668713819931811048770190271,
# 25267680276078003013678680992525463401061632866526,
# 36270218540497705585629946580636237993140746255962,
# 24074486908231174977792365466257246923322810917141,
# 91430288197103288597806669760892938638285025333403,
# 34413065578016127815921815005561868836468420090470,
# 23053081172816430487623791969842487255036638784583,
# 11487696932154902810424020138335124462181441773470,
# 63783299490636259666498587618221225225512486764533,
# 67720186971698544312419572409913959008952310058822,
# 95548255300263520781532296796249481641953868218774,
# 76085327132285723110424803456124867697064507995236,
# 37774242535411291684276865538926205024910326572967,
# 23701913275725675285653248258265463092207058596522,
# 29798860272258331913126375147341994889534765745501,
# 18495701454879288984856827726077713721403798879715,
# 38298203783031473527721580348144513491373226651381,
# 34829543829199918180278916522431027392251122869539,
# 40957953066405232632538044100059654939159879593635,
# 29746152185502371307642255121183693803580388584903,
# 41698116222072977186158236678424689157993532961922,
# 62467957194401269043877107275048102390895523597457,
# 23189706772547915061505504953922979530901129967519,
# 86188088225875314529584099251203829009407770775672,
# 11306739708304724483816533873502340845647058077308,
# 82959174767140363198008187129011875491310547126581,
# 97623331044818386269515456334926366572897563400500,
# 42846280183517070527831839425882145521227251250327,
# 55121603546981200581762165212827652751691296897789,
# 32238195734329339946437501907836945765883352399886,
# 75506164965184775180738168837861091527357929701337,
# 62177842752192623401942399639168044983993173312731,
# 32924185707147349566916674687634660915035914677504,
# 99518671430235219628894890102423325116913619626622,
# 73267460800591547471830798392868535206946944540724,
# 76841822524674417161514036427982273348055556214818,
# 97142617910342598647204516893989422179826088076852,
# 87783646182799346313767754307809363333018982642090,
# 10848802521674670883215120185883543223812876952786,
# 71329612474782464538636993009049310363619763878039,
# 62184073572399794223406235393808339651327408011116,
# 66627891981488087797941876876144230030984490851411,
# 60661826293682836764744779239180335110989069790714,
# 85786944089552990653640447425576083659976645795096,
# 66024396409905389607120198219976047599490197230297,
# 64913982680032973156037120041377903785566085089252,
# 16730939319872750275468906903707539413042652315011,
# 94809377245048795150954100921645863754710598436791,
# 78639167021187492431995700641917969777599028300699,
# 15368713711936614952811305876380278410754449733078,
# 40789923115535562561142322423255033685442488917353,
# 44889911501440648020369068063960672322193204149535,
# 41503128880339536053299340368006977710650566631954,
# 81234880673210146739058568557934581403627822703280,
# 82616570773948327592232845941706525094512325230608,
# 22918802058777319719839450180888072429661980811197,
# 77158542502016545090413245809786882778948721859617,
# 72107838435069186155435662884062257473692284509516,
# 20849603980134001723930671666823555245252804609722,
# 53503534226472524250874054075591789781264330331690
# ]
# num = []
# numArray = []
# digit = []
# carry = 0
# for i in range(0, 100):
#     num = []
#     first = str(array[i])
#     for j in range(0, 50):
#         num.append(first[j])
#     numArray.append(num)
# for i in range(1, 51):
#     nextAdd = []
#     sum = carry
#     carry = 0
#     for j in range(0, 100):
#         sum += int(numArray[j][-i])
#     if len(str(sum)) > 1:
#         stringSum = str(sum)
#         for k in range(0, len(stringSum)):
#             if k == len(stringSum) - 1:
#                 digit.insert(0, stringSum[k])
#             else:
#                 nextAdd.append(stringSum[k])
#     stringAdd = str(nextAdd)
#     for l in range(1, len(nextAdd) + 1):
#         if l - 1 == 0:
#             carry += int(nextAdd[-l])
#         else:
#             carry += int(nextAdd[-l]) * (10**(l - 1))
#     if i == 50:
#         digit.insert(0, carry)
# digit = map(int, digit)
# print 'digit: ' + str(digit)




# # ***** PROBLEM 14 *****
# # The following iterative sequence is defined for the set of positive integers:
# # n -> n/2 (n is even)
# # n -> 3n + 1 (n is odd)
# # Using the rule above and starting with 13, we generate the following sequence:
# # 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
# # It can be seen that this sequence (starting at 13 and finishing at 1) contains 10
# # terms. Although it has not been proved yet (Collatz Problem), it is thought that 
# # all starting numbers finish at 1.
# # Which starting number, under one million, produces the longest chain?
# # *Once the chain starts the terms are allowed to go above one million.*

# print ''
# print '*** PROBLEM 14 ***'
# print ''
# largestSequence = 0
# largestN = 0
# for n in range(2, 1000001):
#     if n % 2 == 0:
#         continue
#     ln = n
#     size = 1
#     while n > 1:
#         if n % 2 == 0:
#             size += 1
#             n = n / 2
#         if n == 1:
#             break
#         if n % 2 != 0:
#             size += 1
#             n = 3 * n + 1
#     if size > largestSequence:
#         largestSequence = size
#         largestN = ln
# print 'Largest Sequence: ' + str(largestSequence)
# print 'Largest N: ' + str(largestN)




# # ***** PROBLEM 15 *****
# # Starting in the top left corner of a 2*2 grid, and only being able to move
# # to the right and down, there are exactly 6 routes to the bottom right corner.
# # How many such routes are there through a 20*20 grid?

# # print ''
# # print '*** PROBLEM 15 ***'
# # print ''
# # right = 0
# # down = 0
# # count = 0
# # def path(r, d):             # This takes over a week to run. I stopped it after
# #     global count            # 46 hours and it was only about a 6th of the way through
# #     if r != 5:
# #         path(r + 1, d)
# #     if d != 5:
# #         path(r, d + 1)
# #     if r == 5 and d == 5:
# #         count += 1
# # path(right, down)
# # print count


# # Problem 15 Optimized
# print ''
# print '*** PROBLEM 15 ***'
# print ''
# product = 1                     # This solves the problem in .051 seconds. It indirectly
# for i in range(21,41):          # solves the problem by finding the permutations
#     product *= i
# permutation = product / math.factorial(20)
# print permutation




# # ***** PROBLEM 16 *****
# # 2**15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
# # What is the sum of the digits of the number 2**1000?

# print ''
# print '*** PROBLEM 16 ***'
# print ''
# sum = 0
# exp = str(2**1000)
# for i in range(0, len(exp)):
#     sum += int(exp[i])
# print 'sum: ' + str(sum)




# # ***** PROBLEM 17 *****
# # If the numbers 1 to 5 are written out in words: one, two, three, four, five
# # then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
# # If all the numbers from 1 to 1000 (one thousand) inclusive were written out 
# # in words, how many letters would be used?
# # NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two)
# # contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use
# # of "and" when writing out numbers is in compliance with British usage.

# print ''
# print '*** PROBLEM 17 ***'
# print ''
# sum = 0
# ones = {0:'',1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine'}
# teens = {10:'ten',11:'eleven',12:'twelve',13:'thirteen',14:'fourteen',15:'fifteen',16:'sixteen',17:'seventeen',18:'eighteen',19:'nineteen'}
# tens = {2:'twenty',3:'thirty',4:'forty',5:'fifty',6:'sixty',7:'seventy',8:'eighty',9:'ninety'}
# for i in range(1,1001):
#     number = str(i)
#     if len(number) == 1:
#         sum += len(ones[i])
#     if len(number) == 2:
#         if i < 20:
#             sum += len(teens[i])
#         elif int(number[1]) == 0:
#             sum += len(tens[int(number[0])])
#         else:
#             sum += len(tens[int(number[0])] + ones[int(number[1])])
#     if len(number) == 3:
#         lastTwo = number[1:]
#         if lastTwo == '00':
#             sum += len(str(ones[int(number[:1])]) + 'hundred')
#             continue
#         hund = str(ones[int(number[:1])]) + 'hundredand'
#         if int(lastTwo) < 10:
#             sum += len(hund + ones[int(lastTwo)])
#         elif int(lastTwo) > 9 and int(lastTwo) < 20:
#             sum += len(hund + teens[int(lastTwo)])
#         elif int(number[2]) == 0:
#             sum += len(hund + tens[int(number[1])])
#         else:
#             sum += len(hund + tens[int(number[1])] + ones[int(number[2])])
#     if len(number) == 4:
#         sum += len('onethousand')
# print sum




# # ***** PROBLEM 18 *****
# # By starting at the top of the triangle below and moving to adjacent
# # numbers on the row below, the maximum total from top to bottom is 23.
# #    3
# #   7 4
# #  2 4 6
# # 8 5 9 3
# # That is, 3 + 7 + 4 + 9 = 23.
# # Find the maximum total from top to bottom of the triangle below:
# #                             75
# #                           95  64
# #                         17  47  82
# #                       18  35  87  10
# #                     20  04  82  47  65
# #                   19  01  23  75  03  34
# #                 88  02  77  73  07  63  67
# #               99  65  04  28  06  16  70  92
# #             41  41  26  56  83  40  80  70  33
# #           41  48  72  33  47  32  37  16  94  29
# #         53  71  44  65  25  43  91  52  97  51  14
# #       70  11  33  28  77  73  17  78  39  68  17  57
# #     91  71  52  38  17  14  91  43  58  50  27  29  48
# #   63  66  04  68  89  53  67  30  73  16  69  87  40  31
# # 04  62  98  27  23  09  70  98  73  93  38  53  60  04  23

print ''
print '*** PROBLEM 18 ***'
print ''

triangle = '\
75\n\
95 64\n\
17 47 82\n\
18 35 87 10\n\
20 04 82 47 65\n\
19 01 23 75 03 34\n\
88 02 77 73 07 63 67\n\
99 65 04 28 06 16 70 92\n\
41 41 26 56 83 40 80 70 33\n\
41 48 72 33 47 32 37 16 94 29\n\
53 71 44 65 25 43 91 52 97 51 14\n\
70 11 33 28 77 73 17 78 39 68 17 57\n\
91 71 52 38 17 14 91 43 58 50 27 29 48\n\
63 66 04 68 89 53 67 30 73 16 69 87 40 31\n\
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23'

triArray = []
numArray = []
j = 13
i = 0

for line in triangle.split('\n'):
    triArray.append(map(int,line.split(' ')))
while j > -1:                                   # Started from the bottom and created my own version of "minimum cost path" algorithm
    for i in range(0, len(triArray[j])):
        if triArray[j+1][i] > triArray[j+1][i+1]:
            triArray[j][i] += triArray[j+1][i]
        else:
            triArray[j][i] += triArray[j+1][i+1]
    i = 0
    j -= 1
print triArray[0][0]